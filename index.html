<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="技术、点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="天蓝的个人笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="天蓝的个人笔记">
<meta property="og:description" content="技术、点滴">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天蓝的个人笔记">
<meta name="twitter:description" content="技术、点滴">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>天蓝的个人笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天蓝的个人笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/18/jvm详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/18/jvm详解/" class="post-title-link" itemprop="url">'jvm详解'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-18 15:20:04" itemprop="dateCreated datePublished" datetime="2020-02-18T15:20:04+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 12:30:20" itemprop="dateModified" datetime="2020-02-20T12:30:20+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1.基本问题</strong></p>
<blockquote>
<ul>
<li>java内存区域（运行时数据区）</li>
<li>java对象创建过程</li>
<li>对象的访问定位两种方式（句柄和直接指针）</li>
<li>String类和常量池</li>
</ul>
</blockquote>
<p><strong>2.运行时数据区</strong></p>
<blockquote>
<p>jdk1.8之前分为程序计数器、虚拟机栈、本地方法栈、堆、方法区（运行时常量池）、直接内存；<br>jdk1.8之后分为程序计数器、虚拟机栈、本地方法栈、堆、直接内存（元空间）；<br>以下详细说明：</p>
<ul>
<li>程序计数器：线程私有的较小内存空间，是当前线程执行字节码的信号指示器。字节码解释器工作时通过改变这个计数器的值来<br>选取下一条需要执行的字节码指令；生命周期与线程相关，不会出现异常；</li>
<li>java虚拟机栈：线程私有，描述的是java方法执行的内存模型，每次方法调用的数据都是栈传递的，由一个个栈帧组成，每个栈帧<br>都拥有：局部变量表、操作数栈、动态链接、方法出口信息； 局部变量表主要存放了编译器可知的各种基本数据类型和对象引用；<br>生命周期与线程相关，由StackOverFlowError和OutOfMemoryError两种错误；</li>
<li>本地方法栈：线程私有，和虚拟机栈作用类似，区别是：虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机使用到的Native<br>方法服务，本地方法被执行时，本地方法栈会创建一个栈帧，用于存放本地方法的局部变量表、操作数栈、动态链接、出口信息，方法执行<br>完毕后相应的栈帧出栈并释放内存空间，会抛出错误；</li>
<li>堆：线程共享，虚拟机启动时创建，此区域唯一目的是存放实例对象，几乎所有对象实例和数组都是在这里分配内存；通过-Xms和-Xmx<br>调节；</li>
<li>方法区：线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等；通过-XX:PermSize和-XX:MaxPermSize<br>调节，永久代是方法区的一种实现方式。jdk1.8之后被移除，取而代之的是元空间，使用直接内存，用-XX:MetaspaceSize和-XX:MaxMetaspaceSize<br>调节；</li>
<li>运行时常量池：是方法区的异步返，用于存储类中的常量池信息；jdk1.7之后在java堆中开辟了一块内存区域用于存放运行时常量池；</li>
<li>直接内存：直接内存不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但NIO等使用到，也会有OutOfMemoryError错误；</li>
</ul>
</blockquote>
<p><strong>3.对象创建过程</strong></p>
<blockquote>
<ol>
<li>类加载检查：虚拟机遇到new指令时，首先会检查这个指令的参数是否在常量池中定位到这个类的符号引用，并且检查符号引用代表的类是否已被<br>加载过、解析和初始化。如果没有，必须先执行相应的类加载过程；</li>
<li>分配内存：类加载检查通过后，虚拟机会为新生对象分配内存。对象所需内存大小在类加载完成后可确定；java堆中分配方式有指针碰撞和空闲列表<br>两种，选择方式由java堆是否规整决定，而java堆是否规整由垃圾收集器是否有压缩整理功能决定；</li>
<li>初始化零值；</li>
<li>设置对象头；</li>
<li>执行init方法；也就是初始化对象；</li>
</ol>
</blockquote>
<p><strong>4.对象的内存布局</strong></p>
<blockquote>
<p>Hotspot虚拟机中，对象在内存中分为三个区域：对象头、实例数据和对齐填充；<br>对象头包含两部分信息：对象自身的运行时数据（哈希码、GC分代年龄、锁状态标志）和类型指针（指向它的类元数据的指针）；<br>实例数据部分是对象真正存储的有效信息；<br>对齐填充不是必然存在的，仅仅起占位作用；</p>
</blockquote>
<p><strong>5.对象的访问定位</strong></p>
<blockquote>
<p>建立对象是为了使用，java程序通过栈上的引用数据类操作堆上具体对象，对象访问方式由虚拟机实现而定，主要有两种：使用句柄和直接指针；</p>
<ul>
<li>句柄：java堆中会划出一块内存作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>
<li>直接指针：对象实例数据中需要包含到对象类型的指针信息；</li>
<li>句柄好处是reference中存储的是稳定的句柄地址，对象移动时reference本身不改变；直接指针好处是快；</li>
</ul>
</blockquote>
<p><strong>6.类加载过程</strong></p>
<blockquote>
<p>类加载class类型文件主要三步：加载——&gt;连接（验证、准备、解析）——&gt;初始化</p>
<ul>
<li>加载：1.通过全类名获取定义此类的二进制字节流；2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构；3.在内存中生成一个代表该<br>类的CLASS对象，作为方法区这些数据的访问入口；</li>
<li>验证：文件格式验证、元数据验证、字节码验证、符号引用验证；</li>
<li>准备：正式为类变量分配内存并设置类变量初始值的阶段；</li>
<li>解析：虚拟机将常量池内的符号引用替换为直接引用的过程；</li>
<li>初始化：执行类构造器<clinit>()方法的过程；</clinit></li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/12/java基础1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/12/java基础1/" class="post-title-link" itemprop="url">java基础1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-12 15:06:04" itemprop="dateCreated datePublished" datetime="2020-02-12T15:06:04+08:00">2020-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-18 10:11:35" itemprop="dateModified" datetime="2020-02-18T10:11:35+08:00">2020-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>面向对象的特点：</p>
<blockquote>
<ul>
<li>封装：将代码及其处理的数据绑定在一起的一种编程机制；</li>
<li>继承：从已有类继承信息创建新的类；</li>
<li>抽象(N): 将一类对象的共同特征抽取出来构造类的过程；</li>
<li>多态：同一种类型的不同对象在调用相同方法时表现出不同的行为；原因是java中的变量拥有两种类型：编译时类型和运行时类型，具体表现在子类<br>重写父类方法，或者相同方法名不同参数(重载)；重载是编译时的多态性，重写是运行时的多态性；</li>
</ul>
</blockquote>
</li>
<li><p>java中变量、代码块、构造器之间的执行顺序：</p>
<blockquote>
<p>原则是先执行静态、父类、变量、代码块、构造器；因此执行顺序如下：</p>
<ol>
<li>父类中的静态变量；</li>
<li>父类中的静态代码块；</li>
<li>子类中的静态变量；</li>
<li>子类中的静态代码块；</li>
<li>父类中的普通成员变量；</li>
<li>父类中的动态代码块；</li>
<li>父类中的构造器；</li>
<li>子类中的普通成员变量；</li>
<li>子类中的动态代码块；</li>
<li>子类中的构造器；</li>
</ol>
</blockquote>
</li>
<li><p>面向对象设计原则：</p>
<blockquote>
<ul>
<li>开闭原则；</li>
<li>单一职责原则；</li>
<li>里氏代换原则；</li>
<li>依赖倒置原则；</li>
<li>接口隔离原则；</li>
<li>迪米特原则；</li>
<li>合成/聚合复用；(Extend)</li>
</ul>
</blockquote>
</li>
<li><p>String、StringBuffer、StringBuilder区别；</p>
<blockquote>
<ul>
<li>String是不可变对象，任何对string的改变都会生成新的对象；StringBuffer和StringBuilder是可变对象；</li>
<li>StringBuffer是线程安全的，StringBuilder是线程不安全的，效率上StringBuilder较高；</li>
</ul>
</blockquote>
</li>
<li><p>hashCode()和equal().</p>
<blockquote>
<p>hashCode()和equal()用于判断两个对象是否相等；hashCode()用于快速判断对象是否相等；如果hashCode()相同，equal()不一定true；<br>因为一些集合类存储元素时要判断元素是否相同，因此hashCode()和equal()都需要重写，防止集合由于误判添加重复元素；</p>
</blockquote>
</li>
<li><p>java中的内部类.</p>
<blockquote>
<p>java中的内部类分为静态内部类和非静态内部类；</p>
</blockquote>
</li>
</ol>
<p>7.反射.</p>
<blockquote>
<p>java反射是在运行时；对于任意一个已加载的类，都能知道它的所有属性和方法，对于任意的对象，都能调用它的任意方法；这种动态的获取信息和<br>动态的调用对象方法被称为java的反射；</p>
</blockquote>
<p>8.元注解.</p>
<blockquote>
<ul>
<li>@Document.是否被javadoc编入文档</li>
<li>@Target. 标识注解的范围，赋值类型是ElementType.</li>
<li>@Retention. 定义该注解的生命周期.RetentionPolicy.SOURCE、CLASS、RUNTIME.</li>
<li>@Inherited. 是否被继承.</li>
</ul>
</blockquote>
<p>9.泛型.</p>
<blockquote>
<p>泛型即参数化类型；</p>
</blockquote>
<p>10.Integer缓冲池</p>
<blockquote>
<p>new Integer(112)和Integer.valueOf(112)的区别是：new Integer(112)每次都会产生新的对象，Integer.valueOf(112)<br>会使用缓冲池中的对象，多次调用会返回同一对象；这是因为Integer内部默认有个IntegerCache缓冲池，会缓冲-128~127的对象;</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/22/设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/22/设计模式/" class="post-title-link" itemprop="url">'设计模式'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-22 16:11:30 / 修改时间：17:06:22" itemprop="dateCreated datePublished" datetime="2020-01-22T16:11:30+08:00">2020-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>面向对象设计原则</strong></p>
<blockquote>
<ol>
<li>开闭原则：对扩展开放、对修改关闭;</li>
<li>里氏代换原则：任何地方子类能替代其父类被调用;</li>
<li>依赖倒转原则：要依赖于抽象，而不是具体;</li>
<li>接口隔离原则：使用多个隔离接口，而不是单个接口;</li>
<li>单一职责原则：接口职责尽量单一;</li>
<li>迪米特原则： 又称最少原则，一个实体应该极可能少的与其他实体作用;</li>
<li>合成/聚合复用：尽量使用合成/聚合，而不是继承;</li>
</ol>
</blockquote>
<p><strong>创建型模式</strong></p>
<blockquote>
<ol>
<li>单例：饿汉式（提前定义，线程安全）和懒汉式（用到时创建，需要加锁保证线程安全）；</li>
<li>原型：将一个对象作为原型，通过复制object.clone()而克隆新实例；</li>
<li>工厂方法：定义一个用于创建对象的接口；</li>
<li>抽象工厂：提供一个创建产品族的接口；</li>
<li>建造者（Builder）：将一个复杂对象分解成多个部分，根据不同需要而创建它们；</li>
</ol>
</blockquote>
<p><strong>结构型模式</strong></p>
<blockquote>
<ol>
<li>代理：为对象提供一种代理访问该对象，从而限制、增强或修改对象的一些属性；</li>
<li>适配器：将一个接口转换成另外一个接口，从而使原本不兼容的类可以兼容；</li>
<li>装饰：动态的给对象添加一些额外功能;</li>
<li>桥接：将抽象与实现分离，使它们独立变化。通过组合来代替继承；</li>
<li>门面：又称外观模式；对多个复杂的子系统提供一个一致的接口；</li>
<li>享元：运用共享技术有效的支持大量细粒度对象的调用；</li>
<li>组合：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性；</li>
</ol>
</blockquote>
<p><strong>行为模式</strong></p>
<blockquote>
<ol>
<li>模板方法：定义一个操作中的算法骨架，将实现延迟到子类中，使得子类在不改变算法结构的情况下重新定义算法中的某些步骤；</li>
<li>策略：定义一些了算法，并将每个算法封装起来，使他们可以相互替换；</li>
<li>命令：将一个请求封装成一个对象，使发出请求的责任和执行请求的责任分开；</li>
<li>职责链：把请求从链中的一个对象传到下一个对象，直到请求相应为止，通过这种方式去除对象间的耦合；</li>
<li>状态：允许一个对象在其内部状态发生改变时改变其行为能力；</li>
<li>观察者：多个对象间存在一对多关系，当一个对象改变时，把这种改变通知给其他多个对象；</li>
<li>中介者：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必互相了解；</li>
<li>迭代器：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示；</li>
<li>访问者：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素由多个访问者对象访问；<br>10.备忘录：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便之后恢复；<br>11.解释器：提供如何定义语言的文法，以及对语言句子的解释方法；</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/20/Spring常见问题总结1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/Spring常见问题总结1/" class="post-title-link" itemprop="url">'Spring常见问题总结1'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-20 13:56:45" itemprop="dateCreated datePublished" datetime="2020-01-20T13:56:45+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-22 17:32:08" itemprop="dateModified" datetime="2020-01-22T17:32:08+08:00">2020-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1.Spring IOC&amp;AOP</strong><br>IOC即依赖注入，是一种设计思想，将类的创建和依赖交给框架通过配置来管理，资源不由使用资源的双方管理而由第三方管理；可以降低耦合度，资源集中管理使得资源可配置和易管理；<br>IOC容器实际上就是个Map，Map中存放了各种对象；Spring IOC的初始化（实现）过程：</p>
<blockquote>
<blockquote>
<p>xml配置–（读取）–&gt;Resource–（解析）–&gt;BeanDefinition–（注册）–&gt;BeanFactory</p>
</blockquote>
</blockquote>
<p>AOP即面向切面编程，可以为业务模块所共用的逻辑（如事务、日志、权限）封装起来，便于减少系统重复代码、降低耦合，有利于扩展和维护；Spring AOP是基于动态代理的，如果代理<br>对象实现了接口，使用jdk动态代理，如果没有实现接口则使用Cglib实现代理；</p>
<p><strong>2.Spring AOP和AspectJ AOP区别</strong><br>Spring AOP属于运行时增强，AspectJ是编译时增强。Spring AOP基于代理，而AspectJ基于字节码操作；Spring AOP集成了AspectJ，常用的aop注解是AspectJ的；<br>jdk动态代理基于反射生成新的代理类，必须实现接口；</p>
<p><strong>3.Spring的生命周期</strong><br><img src="http://www.plantuml.com/plantuml/svg/dL9DIm9H5DtxIshH7z08Z0ZQX12qVphNUg3pPDwBi9MHaUKWBan8qBw8SPCfRiQAVetlZQxw2xtvQ4Od9yJLyEuzvvvxpXtAaCPYSTxhZB-gN6zk0r9tKOOHhPWYbAKqaW5AYIO1Lgrl3JuIiRYuDYQFUXJIQfKBmNi6jRQU20b5AlYeFPKof3AC62PgyXHfy8UNL521mO85b-26TyqI3UPepiw1Nz4fJqiF_AwxkeZy541ZnKEKEm7gp1-RxyxmOPTVll11HvGCMPtqBwn6rsxiepmue-Ka2kotv703b9To23YRVU1ZYH2mz9J3Pq4AhfBVmEgHFKcIKLR6xzd2G0-0pU0tqnAq9L5O4ZVom8w98lGhtcl9ccYEnF1spiK_coLjdGMBhNY8g76yDv87vfKsD-m_K5Jg_ER--rDtPSJhCpTDTrzUhydwsAnEsq_JHacydRjStz0EbdeudGClAGMeVOoGRJyYhnsL4gZA3m00"></p>
<p><strong>4.Spring MVC</strong><br>SpringMVC是一个Web开发框架，把后端项目分层为Model、View、Controller，工作原理如下：<br><img src="/images/spring_4.jpg" alt><br>流程说明：</p>
<blockquote>
<ul>
<li>客户端（浏览器）发送请求，直接请求到DispacterServlet;</li>
<li>DispacterServlet根据请求信息调用HandlerMapping，解析请求对应的Handler;</li>
<li>解析到对应的handler后，开始由HandlerAdapter适配器处理;</li>
<li>HandlerAdapter回根据handler来调用真正的处理器开始处理请求，并处理相应业务逻辑;</li>
<li>处理器处理完业务后，会返回一个ModelAndView对象;</li>
<li>ViewResolver会根据逻辑View查找实际的View;</li>
<li>DispacterServlet把返回的Model传给view;</li>
<li>view返回给客户端;</li>
</ul>
</blockquote>
<p>重要组件说明：</p>
<blockquote>
<ul>
<li>前端控制器DispacterServlet;</li>
<li>处理器映射器HandlerMapping;</li>
<li>处理器适配器HandlerAdapter;</li>
<li>处理器Handler(Controller);</li>
<li>视图解析器ViewResolver;</li>
<li>视图View(jsp,freemarker..);</li>
</ul>
</blockquote>
<p><strong>5.拦截器和过滤器</strong><br>过滤器处于客户端和web资源之间，可以针对request和response做过滤或提前设置参数，然后再传入servlet；拦截器是一种AOP；区别如下：</p>
<blockquote>
<p>拦截器是基于java反射机制的，而过滤器是基于函数回调；<br>拦截器不依赖web容器，而过滤器依赖web容器；<br>拦截器作为spring的组件，能通过IOC容器管理，获取spring中各种资源，而过滤器不能；<br>过滤器是在servlet规范中定义的，由servlet容器支持；拦截器是在spring容器内的，由spring框架支持；</p>
</blockquote>
<p>拦截顺序：过滤doFilter前–&gt;拦截器preHandle–&gt;action处理–&gt;拦截器postHandle–&gt;过滤doFilter后 </p>
<p><strong>6.SpringMVC中的异常处理</strong></p>
<blockquote>
<ol>
<li>自定义Exception;</li>
<li>利用ControllerAdvice和ExceptionHandler全局捕获处理;</li>
<li>定义一个返回对象，包括状态码、message、data等；</li>
</ol>
</blockquote>
<p><strong>7. Spring中的设计模式</strong></p>
<blockquote>
<ul>
<li>工厂模式：利用BeanFactory和ApplicationContext创建bean对象;</li>
<li>单例模式：例如bean的作用域为singleton时;</li>
<li>代理模式：AOP的原理;</li>
<li>模板方法：例如JdbcTemplete等;</li>
<li>观察者 ：Sping事件驱动模型;</li>
<li>适配器 ：AOP的增强或通知时使用了适配器模式，Jpa适配不同数据库；</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/07/面试系列二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/07/面试系列二/" class="post-title-link" itemprop="url">'面试系列二'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-07 19:53:42" itemprop="dateCreated datePublished" datetime="2020-01-07T19:53:42+08:00">2020-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 11:07:31" itemprop="dateModified" datetime="2020-02-20T11:07:31+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1.系统拆分</strong></p>
<ol>
<li><p>为什么要将系统进行拆分？</p>
<blockquote>
<p>1.为了提升开发效率，一个大系统多人维护经常会有冲突，系统拆分后，便于职责划分，且模块独立；2.拆分便于扩展，针对不同的模块，<br>性能消耗不一样，可以有针对的扩容等；3.资源隔离，例如拆分后数据库可以独立，从而进行垂直拆分；</p>
</blockquote>
</li>
<li><p>如何进行系统拆分？</p>
<blockquote>
<p>也就是拆分原则：功能模块单一职责；拆分粒度适中；考虑团队结构；业务模型驱动；演进式拆分；避免环形依赖和双向依赖；</p>
</blockquote>
</li>
<li><p>分布式和微服务区别？</p>
<blockquote>
<p>分布式是一种手段，把不同机器分散在不同地方，机器间相互协作完成业务；微服务是一种特殊的分布式；主要是作用不同：微服务重在<br>解耦，使每个模块相互独立；分布式重在资源共享和提升性能；</p>
</blockquote>
</li>
</ol>
<p><strong>2.分布式事务</strong></p>
<blockquote>
<ul>
<li>XA方案：两阶段提交，通常由一个事务管理器负责协调多个数据库事务；不常用：一个系统跨多个库不合适，而且数据库要求严格；</li>
<li>TCC方案：Try、Confirm、Concel；不常用：要自己写回滚或补偿代码，用在对事务严格要求的情况；</li>
<li>本地消息表：利用数据库表来记录消息处理；不常用：因为依赖数据库管理事务，并发情况不好；</li>
<li>可靠消息最终一致性方案：常用方案，利用可靠的MQ来保证消息一致性；</li>
<li>最大努力通知方案：可靠消息最终一致性方案的一种简单版本，如果B执行失败，尽量尝试重试，超过一定次数放弃；</li>
</ul>
</blockquote>
<p><strong>3.高可用系统</strong></p>
<ol>
<li>高可用定义.<blockquote>
<p>高可用描述的是一个系统在大部分时间都是可用的，可以提供服务。高可用代表系统即使在发生硬件故障或系统升级的时候，服务依然可用。</p>
</blockquote>
</li>
<li>判断标准.<blockquote>
<p>一般情况下，使用多少个9来判断一个系统的可用性。例如99.9999%代表该系统在所有的运行时间中只有0.001%的时间是不可用的。</p>
</blockquote>
</li>
<li>哪些情况会导致系统不可用.<blockquote>
<ol>
<li>黑客攻击；</li>
<li>硬件故障；</li>
<li>并发量/用户请求激增导致整个服务宕掉或部分服务不可用；</li>
<li>代码中的坏味道导致内存泄漏或其他问题使程序不可用；</li>
<li>网络架构某个重要角色如nginx或者数据库突然不可用；</li>
<li>自然灾害或人为破坏；</li>
</ol>
</blockquote>
</li>
<li>提高系统可用性方法.<blockquote>
<ul>
<li>注意代码质量，测试严格把关；</li>
<li>使用集群，减少单点故障；</li>
<li>限流；</li>
<li>超时和重试机制；</li>
<li>熔断机制；</li>
<li>异步调用；</li>
<li>使用缓存；</li>
<li>核心应用和服务有限使用更好的硬件；</li>
<li>监控系统资源使用情况增加报警设置；</li>
<li>注意备份，必要时回滚；</li>
<li>灰度发布；</li>
<li>定期检查硬件；</li>
</ul>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/02/Mysql系列4——基础原理3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/Mysql系列4——基础原理3/" class="post-title-link" itemprop="url">'Mysql系列4——基础原理3'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 20:03:19" itemprop="dateCreated datePublished" datetime="2020-01-02T20:03:19+08:00">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-06 20:54:02" itemprop="dateModified" datetime="2020-01-06T20:54:02+08:00">2020-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1.事务简介</strong><br>事务是作为单个逻辑工作单元执行的一系列操作；Spring事务本质上使用数据库锁，也就是数据库事务，Spring事务只有在方法执行过程中出现<br>异常才会回滚，并且只回滚数据库相关的操作；</p>
<p>事务特性ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）；</p>
<p>mysql只有InnoDB和NDB存储引擎支持事务；开启事务：’begin;’或者’start transaction;’，显示提交事务就是commit；回滚事务rollback；<br>自动提交事务autocommit;隐式提交事务：当执行一些特殊语句而导致事务提交，例如ddl、隐式使用或修改mysql数据库中的表等等；保存点<br>的概念savepoint [savepointname]；</p>
<p><strong>2.事务并发执行遇到的问题</strong></p>
<blockquote>
<ul>
<li>脏写：一个事务修改了另一个未提交事务修改过的数据；</li>
<li>脏读：一个事务读取了另一个未提交事务修改过的数据；</li>
<li>不可重复读：一个事务两次读取同一行数据，得到不同结果；</li>
<li>幻读：一个事务中两次读取一个表数据，得到不同结果，或多行或少行；</li>
</ul>
</blockquote>
<p><strong>3.事务隔离级别</strong>（下面只是一种实现方式）</p>
<blockquote>
<ul>
<li>Read Uncommitted: 事务对当前读取的数据不加锁，事务在更新某数据时，必须先对其加行级共享锁直到事务结束；</li>
<li>Read Committed: 事务对当前被读取的数据加行级共享锁，一旦读完立即释放行级共享锁；事务在更新某数据时先加行级排他锁直到事务结束；</li>
<li>Repeatable read: 事务在读取数据时先加行级共享锁直到事务结束；事务在更新时先加行级排他锁直到事务结束；</li>
<li>Serializable: 事务在读取数据时先加表级共享锁直到事务结束；事务在更新时先加表级排他锁直到事务结束；</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读已提交</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>序列化</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody>
</table>
<p><strong>4.MVCC</strong><br>multi-version concurrency control，多版本并发控制；因为加锁太消耗性能，MVCC是同一份数据临时保留多版本的一种方式实现并发控制；对于Mysql<br>的InnoDB来说，只有事务隔离级别是Read Committed和Repeatable Read时会使用MVCC保证不同事务的读写操作并发执行，不同点在于生成ReadView的时机<br>不同，Read Committed在每次执行普通select前生成一个，Repeatable read是在第一次进行普通select前生成一个ReadView，之后都是用这个；</p>
<p>ReadView中比较重要的内容：</p>
<blockquote>
<ul>
<li>m_ids:表示在生成ReadView时当前系统中活跃的读写事务的事务id列表；</li>
<li>min_trx_id:表示生成ReadView时，当前系统中活跃的读写事务中最小的事务id；</li>
<li>max_trx_id:同上，最大的事务id；</li>
<li>creator_trx_id:表示生成该ReadView的事务id；</li>
</ul>
</blockquote>
<p>访问某条记录，按下面步骤判断：</p>
<blockquote>
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</blockquote>
<p><strong>5.锁</strong></p>
<p><strong>6.redo日志</strong><br>redo日志本质上是记录了事务对数据库做了哪些修改；redo日志会把事务在执行过程中对数据库做的所有修改都记录下来，在之后系统崩溃重启后可以把<br>事务所做的任何修改都恢复过来；</p>
<p>redo日志也是先放到缓存log buffer中，刷盘时机：</p>
<blockquote>
<ul>
<li>log buffer空间不足时；</li>
<li>事务提交时；</li>
<li>后台线程定时刷新；</li>
<li>正常关闭服务器；</li>
<li>其他；</li>
</ul>
</blockquote>
<p>redo日志文件组，我们可以修改一些参数：redo日志存放目录、redo日志文件大小、redo日志文件个数；</p>
<p><strong>7.undo日志</strong><br>undo日志是为了回滚记录；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/Mysql系列3——基础原理2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/Mysql系列3——基础原理2/" class="post-title-link" itemprop="url">'Mysql系列3——基础原理2'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 20:38:12" itemprop="dateCreated datePublished" datetime="2019-12-25T20:38:12+08:00">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-02 20:02:12" itemprop="dateModified" datetime="2020-01-02T20:02:12+08:00">2020-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1.Mysql数据目录</strong><br>数据终究要存储在磁盘上，因此Mysql数据目录中包含各种文件，例如表空间、表、视图、日志、进程文件等；因此数据库受文件系统的影响：</p>
<blockquote>
<ul>
<li>数据库名称和表名称不得超过文件系统所允许的最大长度</li>
<li>特殊字符问题</li>
<li>文件长度受文件系统最大长度限制</li>
</ul>
</blockquote>
<p>mysql中有几个系统数据库：</p>
<blockquote>
<ul>
<li>mysql: 存储了Mysql的用户账户和权限信息，一些存储过程、事件的定义信息，一些日志信息、帮助信息以及时区信息；</li>
<li>information_schema: 维护所有其他数据库的信息，是一些描述性信息；</li>
<li>performance_schema: mysql服务器运行过程中的一些状态信息；</li>
<li>sys: 通过视图形式把information_schema和performance_schema结合起来，可以更方便的了解mysql服务器的一些性能信息；</li>
</ul>
</blockquote>
<p><strong>2.InnoDB表空间</strong><br>表空间中每个也都有一个页号FILE_PAGE_OFFSET，这个页号由4个字节组成，如果页设置大小为默认16kb，则一个表空间最多64TB数据；<br>表空间分为独立表空间和系统表空间；对于16KB的页来说，连续64个页是一个区，默认1MB空间；一个索引会生成2个段，一个叶子节点段，<br>一个非叶子节点段；</p>
<p><strong>3.表单访问方法</strong></p>
<blockquote>
<ul>
<li>const: 通过主键或者唯一二级索引列与常数的等值比较来定位一条记录的访问方法；</li>
<li>ref: 搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法；</li>
<li>ref_or_null: 搜索条件为（二级索引列与常数等值比较）or（二级索引列为null）；</li>
<li>range: 二级索引匹配区间值；</li>
<li>index: 只需要遍历二级索引记录的访问方法；</li>
<li>index merge: 使用多个索引来完成一次查询；</li>
<li>all: 全表扫描；</li>
</ul>
</blockquote>
<p><strong>4.连接</strong><br>连接分为内连接和外连接，区别在于：驱动表中的记录即使在被驱动表没有匹配，是否加入到结果集中；<br><br>驱动表只访问一次，被驱动表可能被访问多次，访问次数取决于对驱动表执行单表查询后的结果集中的记录数，这种连接执行方式称为嵌套循环连接；尽量减少访问被驱动表的次数；</p>
<p><strong>5.成本</strong><br>mysql中一条查询语句的执行成本是由两个方面组成：IO成本和CPU成本；<br><br>mysql执行查询语句前会先分析所有可用方案的执行成本，对比找出成本最低的方案，也就是执行计划；</p>
<blockquote>
<ol>
<li>根据搜索条件，找出所有可能使用的索引；</li>
<li>计算全表扫描的代价；</li>
<li>计算使用不同索引执行查询的代价；</li>
<li>对比各种执行方案的代价，找出成本最低的那个；</li>
</ol>
</blockquote>
<p>因此需要注意可能存在的索引计算代价花费时间过长造成的负优化，一些成本常数可设置；</p>
<p><strong>6.统计数据的收集</strong><br>InnoDB默认是以表为单位来收集和存储统计数据的，这些统计数据可用是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据；<br><br>innodb_stats_persistent控制着使用永久性统计数据还是非永久性统计数据；<br><br>innodb_stats_persistent_sample_pages控制着永久性统计数据的采样页面数量；<br><br>innodb_stats_transient_sample_pages控制着非永久性统计数据的采样页面数量；<br><br>innodb_stats_auto_recalc控制着是否自动重新计算统计数据。</p>
<p>我们可以针对某个具体的表，在创建和修改表时通过指定STATS_PERSISTENT、STATS_AUTO_RECALC、STATS_SAMPLE_PAGES的值来控制相关统计数据属性。</p>
<p>innodb_stats_method决定着在统计某个索引列不重复值的数量时如何对待NULL值。</p>
<p><strong>7.查询优化（内部）</strong></p>
<blockquote>
<ul>
<li>条件化简；</li>
<li>外连接消除；</li>
<li>子查询优化；</li>
</ul>
</blockquote>
<p><strong>8.Explain执行计划</strong><br>格式：[explain] [format=json] sql;<br>optimizer_trace参数可以启用查看详细的执行优化过程；</p>
<p><strong>9.Buffer Pool</strong></p>
<ol>
<li>磁盘太慢，所以要用内存做缓存；Buffer Pool本质是InnoDB向操作系统申请的一段连续的内存空间，可通过innodb_buffer_pool_size来调整大小；<br></li>
<li>Buffer Pool向操作系统申请的连续内存由控制块和缓存页组成，InnoDB使用链表来管理Buffer Pool，free链表中每个节点都代表一个空闲的缓存页，为了快速定位页是否被加载到Buffer Pool，使用表空间号+页号作为key，<br>缓存页作为value，建立哈希表；<br></li>
<li>Buffer Pool中被修改的页被称为脏页，脏页不会立即刷新，而是加入flush链表，待之后的某个时间点同步到磁盘上；LRU链表分为young和old两个区域；<br></li>
<li>每个buffer pool中都有各自独立的链表，一个buffer pool实例由若干chunk组成；</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/24/Mysql系列2——基础原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/24/Mysql系列2——基础原理/" class="post-title-link" itemprop="url">'Mysql系列2——基础原理'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-24 14:37:12" itemprop="dateCreated datePublished" datetime="2019-12-24T14:37:12+08:00">2019-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-25 20:25:59" itemprop="dateModified" datetime="2019-12-25T20:25:59+08:00">2019-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1.Mysql客户端和服务端通信方式</strong></p>
<blockquote>
<ul>
<li>TCP/IP通信，最常用方式，例如客户端连接：msql -hhost -uusername -ppasswd -P3306 [database]</li>
<li>命令管道和共享内存，windows可选连接方式.</li>
<li>Unix域套接字文件，类unix系统可选.</li>
</ul>
</blockquote>
<p><strong>2.服务端处理客户端请求</strong></p>
<p><img src="/images/Mysql_1.png" alt><br>整个过程分为三个部分：连接管理、解析优化、存储引擎.<br>常用命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tableName() <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tableName <span class="keyword">engine</span>=MyISAM;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.服务端参数</strong></p>
<p>服务端启动参数可以直接在启动时添加，例如mysqld –skip-networking；</p>
<p>服务端启动时读取配置文件my.ini或my.cnf，按照一定顺序读取；</p>
<p>配置文件中，按照分组概念配置，不同启动命令可以读取不同的组；</p>
<p>服务器启动后，有很多系统变量，影响着服务器的行为，显示：show variables [like (匹配项)];</p>
<p>同时服务器启动后，会有状态变量，可以查看服务器的状态：show status [like (匹配项)];</p>
<p><strong>4.字符集和比较规则</strong></p>
<p>mysql中UTF-8分为utf8和utf8mb4，utf8是阉割版的utf8，1-3个字节，utf8mb4对应utf8，1-4个字节；<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="built_in">character</span> <span class="keyword">set</span>/<span class="keyword">charset</span> (<span class="keyword">like</span> [匹配项]);</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">collation</span> (<span class="keyword">like</span> [匹配项]);</span><br></pre></td></tr></table></figure></p>
<p>mysql中比较规则后缀：_ai和_as区分重音，_ci和_cs区分大小写，_bin以二进制形式比较；</p>
<p>mysql中有4个字符集和比较规则级别：服务器、数据库、表、列；<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编解码过程：</span><br><span class="line">character_set_client: 服务器解码请求时使用字符集</span><br><span class="line">character_set_connection: 服务器处理请求时会把请求字符串从character_set_client转码到character_set_connection;</span><br><span class="line">character_set_result: 服务器向客户端返回结果时使用的字符集</span><br><span class="line">一般建议这三个参数设置一样.</span><br></pre></td></tr></table></figure></p>
<p><strong>5.InnoDB记录存储结构</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InnoDB将数据分为若干页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16kb；</span><br><span class="line">InnoDB数据按行存储，因此有行格式：Compact、Redundant、Dynamic、Compressed;</span><br><span class="line">指定或修改行格式语法：</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure></p>
<p>其中Compact和Redundant行格式如下：<br><img src="/images/Mysql_2.png" alt><br>Dynamic和Compact行格式类似，不同的地方在于行溢出的处理；Compressed行格式是压缩格式；</p>
<p>一个页一般16Kb，当记录的数据太大存放不了，会存放到其他页，这种情况被称为行溢出，发生行溢出的主要是varchar(m),blob,text；</p>
<p><strong>6.InnoDB数据页结构</strong><br>总的来说，一个InnoDB的数据页被分成7个部分，如下图：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>File Header</td>
<td>文件头部</td>
<td>38字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>页面头部</td>
<td>56字节</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td>Infimum + Supremum</td>
<td>最小记录和最大记录</td>
<td>26字节</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td>User Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>页面目录</td>
<td>不确定</td>
<td>页中的某些记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>文件尾部</td>
<td>8字节</td>
<td>校验页是否完整</td>
</tr>
</tbody>
</table>
<p>每个记录的头信息中都有一个next_record属性，从而使页中的属性串成一个单链表；<br><br>InnoDB会把页中的记录划分成若干组，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page Directory中，<br>所以在一个页中根据主键查找非常快，先通过二分法确定该记录所在槽，再通过记录的next_record属性遍历该槽<br>所在组中的各个记录；<br><br>每个数据页的File Header部分都有上一个和下一个页的编号，所有数据页会组成一个双链表；<br><br>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和页面最后修改时对应的LSN值，<br>如果首部和尾部的校验和LSN校验不成功的话，就说明同步过程出现了问题。</p>
<p><strong>7.B+树索引</strong><br>每个页记录头信息有个record_type属性：</p>
<blockquote>
<ul>
<li>0: 普通用户记录</li>
<li>1: 目录项记录</li>
<li>2: 最小记录</li>
<li>3: 最大记录</li>
</ul>
</blockquote>
<p>InnoDB中，为了检索方便，使用B+树结构管理数据；叶子节点全部是用户数据页，非叶节点都是目录页，目录项记录<br>只存储主键值和对应的页号，目录项过多又由目录来管理，层层嵌套形成了B+树；<br></p>
<blockquote>
<ul>
<li>聚簇索引：1.使用记录主键值的大小进行记录和页的排序；2.B+树的叶子节点存储的是完整的用户记录；</li>
<li>二级索引：1.使用非主键列进行记录也页排序；2.B+树叶子节点存储的不是完整用户记录，而是【非主键列+主键】；3.目录项记录中不再是【主键+页号】，而是【非主键列+页号】，需要回表才能找到完整记录；</li>
<li>联合索引：1.例如建一个C2和C3列的联合索引，先把各个记录和页按照C2列进行排序；在C2列相同情况下，采用C3列进行排序；本质上是二级索引，但多个列只有一个索引；</li>
</ul>
</blockquote>
<p>InnoDB中B+树索引的生成是自上而下的，一个B+树索引的根节点自诞生之日起，就不再移动；<br><br>MyISAM中，索引也是树形结构，索引与数据分开存储，索引中存储的是主键值+行号，每次查询都需要回表操作；<br></p>
<p><strong>8.索引的使用</strong></p>
<ol>
<li>首先明确索引代价=空间+时间（增删改），索引适用一些情况，具体问题具体分析；<blockquote>
<ul>
<li>全值匹配</li>
<li>匹配左边列</li>
<li>匹配范围值</li>
<li>精确匹配第一列并范围匹配另外一列</li>
<li>用于排序、分组</li>
</ul>
</blockquote>
</li>
<li>回表代价巨大，如果使用二级索引查询，结果需要二级索引+聚簇索引，且这种情况下聚簇索引通常是随机IO，因此需要回表的记录越多，使用二级索引的性能越低；</li>
<li>为了清除回表的性能损耗，建议查询列表中只包含索引列；</li>
<li>使用索引时需要注意以下事项：<blockquote>
<ul>
<li>只为用于搜索、排序、分组的列建立索引</li>
<li>为基数大的列建立索引</li>
<li>索引列的类型尽量小</li>
<li>可以只对字符串的前缀建立索引</li>
<li>只有索引列在比较表达式中单独出现才适用索引</li>
<li>为了尽可能减少聚簇索引的页分裂和记录位移，建议主键拥有AUTO_INCREMENT属性</li>
<li>定位并删除表中的重复和冗余索引</li>
<li>尽量使用覆盖索引进行查询，避免回表的性能损耗</li>
</ul>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/21/oracle系列——wallet使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/21/oracle系列——wallet使用/" class="post-title-link" itemprop="url">'oracle系列——wallet使用'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-21 13:00:54 / 修改时间：14:09:07" itemprop="dateCreated datePublished" datetime="2019-12-21T13:00:54+08:00">2019-12-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/oracle/" itemprop="url" rel="index">
                    <span itemprop="name">oracle</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1.前言</strong><br>这几天客户项目上用到oracle wallet，调研对接和使用问题，做一下总结.</p>
<p><strong>2.oracle wallet作用简介</strong><br>oracle wallet主要用于安全方面，可以免密登陆，从而不暴露用户名和密码；一般这种不用用户名密码的，肯定是用证书了，so，这就是oracle wallet；</p>
<p><strong>3.基本使用</strong><br>这里不建议使用docker容器的oracle，因为测试的大部分oracle镜像都缺胳膊少腿的，所以还是自己搭一个oracle服务器吧；<br>引用一个搭建步骤：<a href="https://www.acgist.com/article/497.html，可能会报错，直接搜相关问题解决；" target="_blank" rel="noopener">https://www.acgist.com/article/497.html，可能会报错，直接搜相关问题解决；</a></p>
<p>然后就是创建和使用wallet.（服务端创建）</p>
<blockquote>
<ul>
<li>创建wallet:新建一个目录，执行命令.————mkstore -wrl &lt;wallet_location&gt; -create</li>
<li>创建客户端连接服务端的网络连接串，每个连接串对应一个数据库用户，在$ORACLE_HOME/network/admin/tnsnames.ora文件中.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myorcl =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.100.1.111)(PORT = 1521))</span><br><span class="line">    (CONNECT_DATA=</span><br><span class="line">      (SERVER = DEDICATED)</span><br><span class="line">      (SERVICE_NAME=acgist)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>配置wallet添加用户认证信息.————mkstore -wrl &lt;wallet_location&gt; -createCredential myorcl </li>
<li>在$ORACLE_HOME/network/admin/sqlnet.ora中配置&lt;wallet_location&gt;；<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WALLET_LOCATION=(SOURCE=(METHOD=FILE)(METHOD_DATA=(DIRECTORY=/home/oracle/wallet_111)))</span><br><span class="line">SQLNET.WALLET_OVERRIDE = TRUE</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>然后可以在服务端先测试一下: sqlplus /@myorcl，如果能直连成功，则说明没问题；</li>
</ul>
</blockquote>
<p>在客户机上免密登陆.</p>
<blockquote>
<ul>
<li>需要先安装oracle的客户端，设置相关环境变量；(客户端和服务端不一定要匹配，我这里服务端是11.2.0.1.0，客户端是12.2.0.1)</li>
<li>把服务端的wallet包拷贝到客户端，假设路径还是/home/oracle/wallet_111</li>
<li>在$ORACLE_HOME/network/admin/下新建tnsnames.ora和sqlnet.ora，内容和要使用的数据库保持一致；</li>
<li>验证: sqlplus /@myorcl</li>
</ul>
</blockquote>
<p><strong>4.应用程序使用wallet——在安装oracle客户端的机器上部署</strong><br>如果客户机上已经安装了oracle客户端，则可以直接使用oci连接，从而无需改造程序；例如笔者用的spring boot，可以直接这样修改数据源配置：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: oracle.jdbc.driver.OracleDriver</span><br><span class="line">    url: jdbc:oracle:oci://@myorcl</span><br><span class="line">    username:</span><br><span class="line">    password:</span><br></pre></td></tr></table></figure></p>
<p>这里需要特别注意的是：ojdbc的包一定要与客户端版本一致，例如笔者环境jdk1.8，oracle客户端12.2.0.1，那么要引用下面依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.oracle/ojdbc8 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.oracle&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;12.2.0.1&lt;/version&gt;</span><br><span class="line">           &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>5.应用程序使用wallet——在未安装oracle客户端的机器上部署</strong><br>客户机未安装oracle客户端，则需要使用thin连接，这时需要按照以下步骤改造程序：</p>
<blockquote>
<ul>
<li>在客户机上新建wallet目录并把服务端的wallet拷贝过来，假设目录：/home/oracle/wallet_111，并且在此目录下新建tnsnames.ora并配置使用的数据库.</li>
<li>应用程序中引入以下依赖包.<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.oracle/ojdbc8 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.oracle&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;12.2.0.1&lt;/version&gt;</span><br><span class="line">           &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- https://mvnrepository.com/artifact/com.oracle.ojdbc/oraclepki --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;oraclepki&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;19.3.0.0&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- https://mvnrepository.com/artifact/com.oracle.ojdbc/osdt_cert --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;osdt_cert&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;19.3.0.0&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- https://mvnrepository.com/artifact/com.oracle.ojdbc/osdt_core --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;osdt_core&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;19.3.0.0&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>应用程序中自定义DataSource.<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public DataSource dataSource()&#123;</span><br><span class="line">        OracleDataSource dataSource = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            dataSource = new OracleDataSource();</span><br><span class="line">            Properties properties = new Properties();</span><br><span class="line">            String oracle_net_wallet_location = "/home/oracle/wallet_111";  //目录下应包含wallet的相关文件和tnsnames.ora</span><br><span class="line">            properties.put("oracle.net.tns_admin", oracle_net_wallet_location);</span><br><span class="line">            properties.put("oracle.net.wallet_location", "(source=(method=file)(method_data=(directory="+oracle_net_wallet_location+")))");</span><br><span class="line">            dataSource.setConnectionProperties(properties);</span><br><span class="line">            dataSource.setURL("jdbc:oracle:thin:@myorcl");</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>以上就可以了；</li>
<li>需要注意一些特殊引用，例如quartz.quartz定义数据源有三种方式:配置文件、JNDI、自定义ConnectionProvider；这里笔者选用的第三种方式集成，具体可以查看quartz官方文档，不再赘述.</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/17/面试系列基础知识一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/17/面试系列基础知识一/" class="post-title-link" itemprop="url">'面试系列基础知识一'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-17 10:23:08" itemprop="dateCreated datePublished" datetime="2019-12-17T10:23:08+08:00">2019-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-18 10:11:35" itemprop="dateModified" datetime="2020-02-18T10:11:35+08:00">2020-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1.并发问题产生的根源</strong></p>
<ol>
<li>CPU缓存导致的可见性问题；</li>
<li>CPU切换导致的原子性问题；</li>
<li>编译器优化导致的指令重排序问题；</li>
</ol>
<p><strong>2.HashMap问题</strong></p>
<ol>
<li>基本数据结构：数组+链表；</li>
<li>数据结构根本目的之一是性能；数组都是有下标的，所以查找速度很快，但插入慢；链表只记录下一个元素<br>的地址，优势是插入较快；因为HashMap的添加、修改和查询操作都比较频繁，因此使用数组+链表数据结构；<br>根据hash算法快速定位数组，插入的数据顺序放到链表中，这样综合效率较高；</li>
<li>HashMap的初始化容量机制和扩容机制： 既然HashMap底层是数组，数组初始化时需要指定一个长度，默认<br>初始化一个长度16的数组；有个扩容因子，默认0.75，每次扩容时机是：数组长度*负载因子，每次扩容2倍，<br>保持数组长度为2的幂次方，因为底层存储用的&amp;；</li>
<li>put过程：先对key调用hashCode()得到一个hash值，类型int，然后用hash值与（16-1）进行位运算，从而<br>得到数组下标；为了减少哈希碰撞，获取hash时，会先把key的hashcode和它自己无符号右移16位进行异或<br>运算，这样是为了扩大特征值，再与(16-1)位运算；</li>
<li>链表过长处理： hashmap已经尽力减少哈希冲突，但是终究还是有冲突，如果一个链表过长会影响查询效率，<br>这种情况下，HashMap会把链表结构转换成红黑树，put时，判断当前链表长度是否大于(TREEIFY_THRESHOLD-1)，<br>默认(8-1)，当hashmap扩容时，会判断红黑树节点数量是否大于(NTREEIFY_THRESHOLD)，默认(6-1)，会把<br>红黑树转换成链表；</li>
<li>HashMap的get查询流程：<blockquote>
<blockquote>
<ul>
<li>先计算key的哈希值；</li>
<li>通过哈希值定位key存在哪个数组下标；</li>
<li>找到后看数组下标里面有没有节点，没有就返回null；</li>
<li>有节点的话，区分节点是红黑树还是链表，然后分别使用对应数据结构的查找方法；</li>
<li>根据查找的key和节点里面存的key值判断两个key是不是equals()，equals则返回对应的节点，否则继续<br>匹配下一个节点，直到匹配成功返回节点，或者没有节点匹配后返回null；</li>
</ul>
</blockquote>
</blockquote>
</li>
</ol>
<p><strong>3.ArrayList和LinkedList</strong></p>
<p><strong>4.数据结构——树</strong></p>
<ol>
<li>二叉树的基本特点：左子节点的值比父节点的值要小，右节点的值比父节点要大，高度决定了它的查找效率；本质是一种<br>二分算法的实现；二叉树理想查询时间复杂度是O(logN)，最坏是O(N)；不同的插入顺序导致二叉树的高度不一样，查询<br>效率千差万别，因此产生了平衡二叉树，比较典型的是AVL树和红黑树，AVL树实现复杂且插入和删除性能差，一般用红黑树；</li>
<li>红黑树的定义：任何一个节点都有颜色，红或黑；根节点是黑色的；父节点之间不可能出现两个连续红节点；任何一个节点<br>向下遍历到其子孙的叶子节点，所经过的黑色节点个数必须相等；空节点被认为是黑色；</li>
<li>红黑树通过旋转完成平衡，添加、删除、查找时间复杂度基本都是O(logN)；</li>
<li>B树属于多叉树（平衡多路查找树），排序也是左小右大；B+树是B树基础上衍生的，区别是：B树根节点包含数据，B+树根节点<br>只能由索引，数据全部在叶子节点；</li>
</ol>
<p><strong>5.死锁</strong><br>死锁是什么：</p>
<blockquote>
<p>死锁，是指多个进程循环等待他方占有的资源而无限期的僵持下去的局面；</p>
</blockquote>
<p>死锁产生的必要条件：</p>
<blockquote>
<ul>
<li>互斥条件：每个资源一段时间只能由一个进程占有；</li>
<li>不可抢占条件：已经分配给一个进程的资源不能强制被抢占，只能被占有它的进程释放；</li>
<li>占有且申请条件：已经得到某个资源的进程申请新的资源；</li>
<li>循环依赖条件：有两个或以上的进程组成一个环路，该环路中的每个进程都在等待下一个进程所占有的资源；</li>
</ul>
</blockquote>
<p>死锁的预防：</p>
<blockquote>
<p>针对死锁的必要条件，打破某些条件；</p>
</blockquote>
<p>死锁的避免：</p>
<blockquote>
<ul>
<li>安全序列：系统中的所有进程都能够按照某一种秩序分配资源，并且依次执行完毕，这种进程序列就是安全序列；</li>
<li>银行家算法。</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ank.hao</p>
  <div class="site-description" itemprop="description">技术、点滴</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ank.hao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
