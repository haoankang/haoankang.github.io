<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="技术、点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="天蓝的个人笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="天蓝的个人笔记">
<meta property="og:description" content="技术、点滴">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天蓝的个人笔记">
<meta name="twitter:description" content="技术、点滴">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>天蓝的个人笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天蓝的个人笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/Redis系列2-还是基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/Redis系列2-还是基础/" class="post-title-link" itemprop="url">Redis系列2-还是基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-26 20:41:54" itemprop="dateCreated datePublished" datetime="2020-02-26T20:41:54+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-27 10:51:11" itemprop="dateModified" datetime="2020-02-27T10:51:11+08:00">2020-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>###1. Redis主从架构.<br>Redis主从架构特点：</p>
<blockquote>
<ul>
<li>主服务器负责接收写请求；</li>
<li>从服务器负责接收读请求；</li>
<li>从服务器的数据由主服务器复制过去，主从服务器的数据是一致的；</li>
</ul>
</blockquote>
<p>好处：读写分离、高可用、更高并发量；</p>
<p>复制功能的具体实现：</p>
<blockquote>
<p>复制功能分为两个操作：同步（将从服务器数据库状态更新至主服务器的数据库状态）；命令传播（主服务器状态修改，让主从服务器数据库状态重新一致）；</p>
</blockquote>
<p>同步时，从服务器向主服务器发送PYSNC命令，主要分为两个场景：完整重同步（初次同步）和部分重同步（断电重连），流程如下：</p>
<blockquote>
<p>完整重同步：</p>
<ul>
<li>从服务器向主服务器发送PYSNC命令；</li>
<li>收到PYSNC的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并用缓冲区记录接下来的所有写命令；</li>
<li>RDB文件写完后，发送给从服务器，从服务器接收和载入RDB文件；</li>
<li>主服务器将缓存区中的写命令发送给从服务器，从服务器执行这些命令，达到一致性；</li>
</ul>
</blockquote>
<blockquote>
<p>部分重同步：<br>部分重同步的功能由以下部分组成：主从服务器的复制偏移量、主服务器的复制积压缓冲区、服务器运行的ID；<br>主服务器进行命令传播时，不仅会把命令发送给从服务器，还会把命令写入复制缓冲区；</p>
</blockquote>
<p>命令传播：</p>
<blockquote>
<p>完成了主从同步之后，就进入命令传播阶段；主服务器只要把写命令发送给从服务器，从服务器执行写命令，即可实现主从同步；<br>命令传播阶段，从服务器默认会以秒为间隔向主服务器发送REPLCONF ACK &lt;复制偏移量&gt;</p>
</blockquote>
<p>###2. 哨兵机制保证高可用性</p>
<blockquote>
<p>接上节主从机制，如果从服务器挂了，没影响；但是如果写服务器挂了，就没有服务器处理写请求了；这时哨兵系统会从从服务器中选举一个作为主服务器，<br>当主服务器重连之后，将之前的主服务器设置为从服务器，这个过程叫主备切换。（故障转移）</p>
</blockquote>
<p>哨兵机制主要功能如下：</p>
<blockquote>
<ul>
<li>不停的监控Redis主从服务器是否正常工作；</li>
<li>如果某个服务器有故障，哨兵负责同志管理员；</li>
<li>如果主服务器挂了，会自动选举一个从服务器做主服务器；</li>
<li>可以作为配置中心，能够提供当前主服务器的信息；</li>
</ul>
</blockquote>
<p>哨兵判断主服务器是否下线：主观下线+客观下线；当一个主服务器被判断客观下线后，哨兵集群会选举一个领头哨兵，选举规则较多，总的来说是先到先得；<br>故障转移具体步骤：</p>
<blockquote>
<ul>
<li>在已下线主服务器属下的从服务器中，挑选一个转换为主服务器</li>
<li>让已下线主服务器属下的所有从服务器改为复制新的主服务器</li>
<li>已下线的主服务器重新连接时，让他成为新的主服务器的从服务器</li>
</ul>
</blockquote>
<p>挑选从服务器作为主服务器，规则如下：</p>
<blockquote>
<ul>
<li>跟master断开连接的时长</li>
<li>slave优先级</li>
<li>复制偏移量</li>
<li>run id</li>
</ul>
</blockquote>
<p>###3. 数据丢失<br>即使主从结构+哨兵，redis还是会有数据丢失问题.</p>
<blockquote>
<ul>
<li>主服务器宕机，还没有来得及同步消息；</li>
<li>脑裂导致的数据丢失；</li>
</ul>
</blockquote>
<p>###4. 缓存与数据库双写一致性<br>应用——缓存——数据库；读操作不会造成一致性问题，只有写操作才可能出现，两种解决方案：</p>
<blockquote>
<ul>
<li>写操作时，先删除缓存，再修改数据库；</li>
<li>写操作时，写修改数据库，再删除缓存；</li>
</ul>
</blockquote>
<p>为什么删除缓存，而不是更新缓存？</p>
<blockquote>
<ol>
<li>复杂的缓存场景中，缓存可能需要取几张表的数据计算得出；</li>
<li>更新缓存代价较高；</li>
</ol>
</blockquote>
<p>如果缓存+数据库必须严格一致，可以使用将读写请求串行化到内存队列中；</p>
<p>###5. 其他问题</p>
<ol>
<li><p>RDB原理.</p>
<blockquote>
<p>fork和COW.redis通过fork命令创建子进程来进行RDB操作，子进程创建后，父子进程共享数据段，父进程继续提供服务；</p>
</blockquote>
</li>
<li><p>redis基础数据类型使用场景.</p>
<blockquote>
<ul>
<li>string. 缓存功能、计数器、共享session等；</li>
<li>hash. 一般村结构化数据、对象；</li>
<li>list. 有序列表，可以做一些列表型的数据，如粉丝列表、文章评论列表；也可以用来实现消息队列；</li>
<li>set. set主要用于一些去重的场景；</li>
<li>zset. 排行榜等；</li>
</ul>
</blockquote>
</li>
</ol>
<p>###6. redis集群<br>redis cluster，主要针对海量数据+高可用+高并发；介绍：自动将数据进行分片，每个master上存储部分数据；提供内置的高可用支持，当<br>主节点挂掉，从节点替换；</p>
<p>redis cluster模式下，每个redis要开放两个端口：6379和16379；16379是进行节点间通信的，也就是cluster bus，用的是gossip二进制协议；</p>
<p>节点间的内部通信机制.</p>
<blockquote>
<p>基本通信原理：集群元数据的维护两种方式集中式和gossip协议；</p>
</blockquote>
<p>分布式寻址算法.</p>
<blockquote>
<ul>
<li>hash算法；</li>
<li>一致性hash算法+虚拟节点；</li>
<li>redis cluster的hash slot算法；</li>
</ul>
</blockquote>
<p>跟哨兵模式对比.</p>
<blockquote>
<p>高可用和主备切换与哨兵模式相似，功能更加强大，直接集成了replication和sentinel的功能；</p>
</blockquote>
<p>###7. redis的并发竞争问题，以及redis的CAS方案.<br>并发竞争问题，是指多个客户端同时并发写一个key，可能会出问题；</p>
<p>解决方案：</p>
<blockquote>
<ul>
<li>利用zookeeper的分布式锁，写入前先锁定；</li>
<li>利用数据库的时间戳CAS判定；</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/Redis系列1——基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/Redis系列1——基础/" class="post-title-link" itemprop="url">Redis系列1——基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-25 21:04:00" itemprop="dateCreated datePublished" datetime="2020-02-25T21:04:00+08:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-27 10:04:27" itemprop="dateModified" datetime="2020-02-27T10:04:27+08:00">2020-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>redis简介.</p>
<blockquote>
<p>简单来说，redis就是一个基于内存的数据库；因为读写非常快，高性能且高并发，所以被广泛用于缓存方向；redis用多种数据类型来支持不同的业务场景；<br>redis支持事务、持久化、lua脚本、LRU驱动事件、多种集群方案；</p>
</blockquote>
<p>###1. redis单线程为什么这么快.</p>
<blockquote>
<ol>
<li>纯内存；</li>
<li>非阻塞IO；</li>
<li>单线程避免了线程切换和竞争消耗；</li>
</ol>
</blockquote>
<p>###2. redis特性.</p>
<blockquote>
<ul>
<li>速度快；</li>
<li>持久化；</li>
<li>多种数据结构；</li>
<li>支持多种编程语言；</li>
<li>功能丰富；</li>
<li>简单；</li>
<li>主从复制；</li>
<li>高可用，分布式；</li>
</ul>
</blockquote>
<p>###3. 应用场景.</p>
<blockquote>
<ul>
<li>缓存系统；</li>
<li>计数器；</li>
<li>实时系统；</li>
<li>排行榜；</li>
<li>社交网络；</li>
<li>消息队列系统；</li>
</ul>
</blockquote>
<p>###4. Redis数据结构</p>
<blockquote>
<p>Redis支持丰富的数据结构，常用的如string、list、set、zset、hash等；redis使用对象来表示K和V，Redis中的一个<br>键值对，至少需要创建两个对象，一个键对象，一个值对象；</p>
</blockquote>
<p>redis底层数据结构：</p>
<blockquote>
<p>SDS简单动态字符串：SDS与C字符串的比较：</p>
<ol>
<li>获取字符串长度，SDS时间复杂度O(1)，因为内部存储了length；</li>
<li>SDS不会发生内存溢出问题； 内部动态扩展；</li>
<li>SDS减少内存分配次数； 会分配额外空闲空间；</li>
<li>SDS是二进制安全的；</li>
</ol>
</blockquote>
<blockquote>
<p>链表，redis的链表特性：</p>
<ol>
<li>无环双向链表；</li>
<li>获取表头指针、表尾指针、链表长度O(1)；</li>
<li>链表使用void*指针保存节点值，可以保存各种不同类型的值；</li>
</ol>
</blockquote>
<blockquote>
<p>哈希表，也叫字典；redis的哈希表中有两个哈希表，用于渐进式rehash；</p>
</blockquote>
<blockquote>
<p>跳跃表；shiplist；redis的跳表实现由zskiplist和zskiplistNode组成，zskiplist保存跳表的信息（表头、表尾、长度），<br>zskiplistNode表示跳表中的节点；</p>
</blockquote>
<blockquote>
<p>整数集合，set的底层数据结构之一；</p>
</blockquote>
<blockquote>
<p>压缩列表，list和hash的底层实现之一；是由一系列特殊编码的连续内存块组成的顺序性数据结构；</p>
</blockquote>
<p>###4. 基本数据类型.</p>
<blockquote>
<ul>
<li>string字符串；可以是字符串、整形、浮点型； SDS字符串；</li>
<li>list；一个双向链表，链表的每个节点上都包含一个字符串； 快速链表=链表+压缩链表；</li>
<li>set；包含字符串的无序收集器；</li>
<li>zset；字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小确定； 跳表，其实就是多层链表；<blockquote>
<p>当数据量少时，由一个ziplist实现；当数据量多时，由一个dict+skiplist实现，dict用来查数据到分数的对应关系，<br>而skiplist用来根据分数查询数据；</p>
</blockquote>
</li>
<li>hash；包含键值对的无序散列表； redis是渐进式rehash的；</li>
</ul>
</blockquote>
<p>redis的rehash过程：</p>
<blockquote>
<p>在对哈希表进行扩展或者收缩操作时，rehash过程不是一次完成的，因为如果数据量过大时，一次性rehash会有庞大的<br>计算量，这很可能导致服务器一段时间内停止服务；</p>
</blockquote>
<blockquote>
<p>redis的所有数据类型都被封装成对象，hash结构的对象内部有两个哈希表，一个用于存放真实的K-V数据，另一个用于扩容；</p>
<ol>
<li>字典内维持一个索引计数器，用于表示是否在进行rehash；</li>
<li>rehash期间对字典进行增删改查时，除了执行指令外，还会将h[0]中数据rehash到h[1]中；</li>
<li>字典操作不断进行，最终rehash完时，计数器设为-1；</li>
<li>渐进式rehash过程中，字典会同时使用两个哈希表，删改查操作会同时在两个哈希表上进行；新增只会在h[1]上新增，<br>查询时，优先查h[0]，如果查不到查询h[1]；</li>
</ol>
</blockquote>
<p>redis对象的一些细节.</p>
<blockquote>
<ol>
<li>服务器在执行某些命令时，会先检查给定的键的类型；</li>
<li>redis对象系统带有引用计数实现的内存回收机制；‘</li>
<li>redis会共享0-9999的字符串对象；</li>
<li>对象会记录自己最后一次被访问时间，这个时间可以用于计算对象的空转时间；</li>
</ol>
</blockquote>
<p>###5. redis线程模型.</p>
<blockquote>
<p>redis内部使用文件事件处理器File event handler，这个文件事件处理器是单线程的，所以redis被称为单线程的；它采用IO多路复用机制监听<br>多个socket，根据socket上事件来选择对应的事件处理器进行处理；</p>
<p>主要有两类事件：文件事件，就是对Socket操作的抽象；时间事件，就是对定时操作的抽象；</p>
<p>这个文件事件处理器包含4个部分：</p>
<ul>
<li>多个socket；</li>
<li>IO多路复用程序；</li>
<li>文件事件分派器；</li>
<li>事件处理器；</li>
</ul>
</blockquote>
<p>###6. redis与Memcached的区别.</p>
<blockquote>
<ol>
<li>redis支持更丰富的数据类型；Memcached只有string类型；</li>
<li>redis支持持久化；Memcached不支持；</li>
<li>memcached原生不支持集群，而redis支持集群；</li>
<li>memcached是多线程、非阻塞IO复用的网络模型，Redis是单线程IO多路复用模型；</li>
</ol>
</blockquote>
<p>###7. redis过期时间和淘汰机制；</p>
<blockquote>
<p>redis可以设置expire time过期时间；redis使用定期删除+惰性删除维护key，注意定期删除是随机抽取的；<br>如果定期删除漏掉了很多过期key，也没及时去查（没走惰性删除），大量key堆积导致内存耗尽，此时就需要内存淘汰机制；</p>
<p>redis内存淘汰机制：</p>
<ul>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰；</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰；</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰；</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）；</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰；</li>
<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。一般不用；</li>
<li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰；</li>
<li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key；</li>
</ul>
<p>使用redis时，为了提高缓存命中率，需要保证缓存数据都是热点数据，可以将内存最大使用量设置为热点数据占用的内存量，<br>然后启用allkeys-lru策略；</p>
</blockquote>
<p>###8. redis持久化机制.</p>
<blockquote>
<ul>
<li>快照RDB.Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。创建快照的几种方式：<blockquote>
<ul>
<li>BGSAVE命令； 创建出一个子进程来创建RDB文件，服务器进程可以继续服务；</li>
<li>SAVE命令； 会阻塞Redis服务器进程，服务器不能接收任何请求，直到RDB文件创建完毕；</li>
<li>save选项；</li>
<li>SHUTDOWN命令；</li>
<li>一个redis服务器连接另一个redis服务器；</li>
</ul>
</blockquote>
</li>
<li>只追加文件AOF.开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。</li>
</ul>
</blockquote>
<p>重写/压缩AOF.</p>
<blockquote>
<p>AOF虽然在某个角度可以将数据丢失降低到最小而且对性能影响也很小，但是极端的情况下，体积不断增大的AOF文件很可能会用完硬盘空间。另外，如果AOF体积过大，那么还原操作执行时间就可能会非常长。<br>为了解决AOF体积过大的问题，用户可以向Redis发送 BGREWRITEAOF命令 ，这个命令会通过移除AOF文件中的冗余命令来重写（rewrite）AOF文件来减小AOF文件的体积。<br>BGREWRITEAOF命令和BGSAVE创建快照原理十分相似，所以AOF文件重写也需要用到子进程，这样会导致性能问题和内存占用问题，和快照持久化一样。更糟糕的是，如果不加以控制的话，AOF文件的体积可能会比快照文件大好几倍。</p>
</blockquote>
<p>RDB和AOF对过期键的策略.</p>
<blockquote>
<p>执行SAVE或BGSAVE创建RDB文件时，过期键不会保存到RDB文件中；载入RDB文件时，过期的键会被忽略；</p>
</blockquote>
<blockquote>
<p>写入AOF文件时，过期键还没被定期/惰性删除时，不会影响写入AOF；载入AOF文件时，过期的键会被忽略；</p>
</blockquote>
<blockquote>
<p>复制模式下，主服务器来控制从服务器统一删除过期键；</p>
</blockquote>
<p>###9. Redis事务.</p>
<blockquote>
<p>Redis通过MULTI、EXEC、WATCH等命令实现事务功能；事务通过一次性将多个命令打包，然后一次性、顺序执行；redis事务总是具有ACI特性；</p>
<p>redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</p>
</blockquote>
<p>###10. 缓存雪崩、缓存穿透、缓存击穿。</p>
<blockquote>
<ul>
<li>缓存雪崩. 缓存同一时间大面积的失效，或者redis挂掉了，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。<br>解决方案.一般用设置随机过期时间；<blockquote>
<ul>
<li>事前：实现redis的高可用：主从+哨兵</li>
<li>事中：利用本地缓存和Hystrix限流；</li>
<li>事后：redis持久化，快速启动恢复缓存数据；</li>
</ul>
</blockquote>
</li>
<li>缓存穿透. 大量无效key请求，直接请求数据库，导致数据库崩溃；解决方案：缓存无效key，校验，布隆过滤器；</li>
<li>缓存击穿. 同一个key大量请求，某个时间点key过期，大量请求会直接到数据库；解决方案：设置热点key永不过期；</li>
</ul>
</blockquote>
<p>###11. Redis常见的性能问题和解决方案.</p>
<blockquote>
<ol>
<li>Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响非常大，会间断性<br>暂停服务，所以Master最好不要写内存快照；</li>
<li>Master AOF持久化，如果不进行AOF重写，AOF文件会过大而影响Master重启速度；Master不要做任何持久化工作，由<br>某个Slave开启AOF备份数据，策略是每秒一次；</li>
<li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网中；</li>
<li>尽量避免在压力很大的主库上增加从库；</li>
<li>主从复制不要用图状结构，用单向链表结构更稳定；例如Master &lt; Slave1 &lt; Slave2 …这样结构方便解决单点故障<br>问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1，其他不变；</li>
</ol>
</blockquote>
<p>###12. Redis同步机制.</p>
<blockquote>
<p>主从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步<br>到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点<br>进行重放完成同步过程；</p>
</blockquote>
<p>###13. Redis集群.</p>
<blockquote>
<ul>
<li>Redis Sentinel高可用，在master宕机时会自动将slave提升成master，继续提供服务；</li>
<li>Redis Cluster扩展性，在单个redis内存不足时，使用Cluster进行分片存储；</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/Mysql系列5——补充/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/Mysql系列5——补充/" class="post-title-link" itemprop="url">'Mysql系列5——补充'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-25 16:41:25" itemprop="dateCreated datePublished" datetime="2020-02-25T16:41:25+08:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-27 14:39:17" itemprop="dateModified" datetime="2020-02-27T14:39:17+08:00">2020-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>##1. 索引.<br>索引的优点.（优点就是要从时间、空间考虑）</p>
<blockquote>
<ul>
<li>大大减少了服务器需要扫描的数据行数；</li>
<li>帮助服务器避免了进行排序和分组，以及避免创建临时表；</li>
<li>将随机IO变为顺序IO；</li>
</ul>
</blockquote>
<p>索引为什么可以加快检索速度？</p>
<blockquote>
<p>索引使无序的数据变为有序的数据，然后利用算法如二分类的检索；以B+树为例，索引会减少磁盘IO次数；</p>
</blockquote>
<p>索引优化.</p>
<blockquote>
<ul>
<li>独立索引.</li>
<li>多列索引.</li>
<li>索引列的顺序.让选择性强、即基数大的列放在前面；</li>
<li>前缀索引.</li>
<li>覆盖索引.</li>
</ul>
</blockquote>
<p>索引类型.</p>
<blockquote>
<p>主键索引(primary key)、唯一索引(unique key)、普通索引(key)、全文索引.</p>
</blockquote>
<p>索引失效.</p>
<blockquote>
<ul>
<li>如果优化器分析全表扫描比使用索引快，则不走索引；</li>
<li>如果条件中有or，则不走索引；</li>
<li>复合索引，如果不符合最左前缀原则，则不走索引；</li>
<li>like以%开头；</li>
<li>其他；</li>
</ul>
</blockquote>
<p>为什么用B+树而不是B树和红黑树做索引？</p>
<blockquote>
<p>首先Mysql是以磁盘IO次数衡量查询效率的；B树和B+树层级很少，目的就是为了减少磁盘IO次数，但B树节点存储数据，因此节点较大，磁盘IO一次读取<br>的数据有限，单个数据变大，就需要多次IO，因此更加耗时；B+树数据都在叶子节点，因此可以将所有叶子节点用指针串起来，这样就能顺序IO访问速度<br>更快；</p>
<p>红黑树层级过多，不适合存储大数据量；</p>
</blockquote>
<p>##2. 数据切分.<br>切分类型：</p>
<blockquote>
<ul>
<li>水平切分：将一个表的数据拆分到多个表中，例如将订单按时间每天切分；</li>
<li>垂直切分：将一个表列切分到多个表中，可以根据列是否经常使用等切分，例如订单号和用户id；</li>
</ul>
</blockquote>
<p>切分策略：</p>
<blockquote>
<p>哈希取模（hash(key)%N）、范围、映射表；</p>
</blockquote>
<p>切分存在的问题：</p>
<blockquote>
<ul>
<li>分布式事务问题；</li>
<li>连接；</li>
<li>ID唯一性；</li>
</ul>
</blockquote>
<p>分库分表中间件：<br>sharding-jdbc：client层方案，优点：不用部署额外中间件，运维成本低，不需要代理曾二次转发请求，性能高；缺点：耦合度高；<br>Mycat：proxy层方案，优点：对于各项目透明；</p>
<p>分布式ID生成方案：</p>
<blockquote>
<ul>
<li>UUID</li>
<li>数据库自增ID</li>
<li>批量生成ID</li>
<li>Redis生成ID</li>
<li>Twitter的snowflake算法</li>
<li>其他分布式ID生成器</li>
</ul>
</blockquote>
<p>##3. 主从复制和读写分离.<br>主从复制.</p>
<blockquote>
<p>主要涉及三个线程：</p>
<ul>
<li>binlog线程：负责将主数据库上的数据更改写入二进制文件binlog中；</li>
<li>IO线程：负责从主数据库上读取二进制文件，并写入从服务器的中继日志中；</li>
<li>SQL线程：负责读取中继日志并重放其中的SQL语句；</li>
</ul>
<p>高并发场景下，从库数据一定比主库慢一些，是有延时的；mysql在主从复制这块有两个机制：半同步复制用来解决主库<br>数据丢失，并行复制用来解决主从延时问题；</p>
<p>主从同步延时问题解决方案：</p>
<blockquote>
<ul>
<li>分库，将一个主库拆分成多个主库，每个主库的并发量就减少了几倍，此时主从延迟可以忽略不计；</li>
<li>开启Mysql的并行复制机制；</li>
<li>代码层注意问题；</li>
<li>严格要求的情况下，就读主库；</li>
</ul>
</blockquote>
</blockquote>
<p>读写分离.</p>
<blockquote>
<p>主服务器用来处理写操作和实时性要求较高的读操作，从服务器处理读请求；可以用动态数据源切换方式实现；</p>
</blockquote>
<p>主从不一致：</p>
<blockquote>
<p>业务可以接受，系统不优化；<br>强制读主库；<br>在cache中记录发生了哪些写操作，来路由读主库还是从库；</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/java基础2——线程和并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/java基础2——线程和并发/" class="post-title-link" itemprop="url">'java基础2——线程和并发'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-25 15:23:49 / 修改时间：17:38:33" itemprop="dateCreated datePublished" datetime="2020-02-25T15:23:49+08:00">2020-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>###1. 使用和创建线程.<br>三种方式：实现Runnable接口、实现Callable接口、继承Thread.</p>
<p>###2. 基础线程机制.<br>Executor并发框架，有三种基础的Executor：FixedThreadPool、SingleThreadExecutor、CachedThreadPool.</p>
<p>###3. 锁.<br>synchronized和ReentrantLock比较：</p>
<blockquote>
<ul>
<li>锁的实现：synchronized是jvm实现的，ReentrantLock是jdk实现的；</li>
<li>性能：新版本synchronized优化了很多，例如锁自旋、锁消除等手段， 性能已经相差不多；</li>
<li>等待可中断：ReentrantLock可中断，synchronized不可中断；</li>
<li>公平锁：公平非公平是对获取锁而言，ReentrantLock支持公平锁和非公平锁，synchronized只有非公平锁；</li>
<li>锁绑定多个条件：ReentrantLock可绑定多个Condition对象.</li>
</ul>
</blockquote>
<p>wait()和sleep()区别：</p>
<blockquote>
<ul>
<li>wait()会释放锁，而sleep()不会；</li>
<li>sleep()是静态方法，wait()不是；</li>
<li>wait()需要唤醒，或超时唤醒；</li>
</ul>
</blockquote>
<p>线程状态：<br>新建、可运行、阻塞、无限期等待、限期等待、死亡.</p>
<p>###4. J.U.C–AQS.<br>AQS：抽象队列同步器，是java.util.concurrent包的核心，是构建并发工具类的框架；用于实现依赖于FIFO等待队列的阻塞锁<br>和相关同步器；</p>
<blockquote>
<ul>
<li>CountDownLatch. 用来控制一个或多个线程等待多个线程；核心方法countDown()、await()；</li>
<li>CyclicBarrier. 用来控制多个线程互相等待，只有所有多个线程到达后，程序才继续执行；核心方法有await()、reset();<br>与CountDownLatch的区别是：可以通过reset()方法循环调用，所以叫循环屏障；</li>
<li>Semaphore. 信号量，控制对互斥资源的访问线程数；核心方法acquire()、release()；</li>
<li>Exchange. 多个线程间交换数据；</li>
</ul>
</blockquote>
<p>###5. Java内存模型.<br>分为主内存和工作内存.</p>
<p>内存间的交互操作：<br>read、load、use、assign、store、write、lock、unlock.</p>
<p>###6. 多线程开发实践.</p>
<blockquote>
<ol>
<li>给线程命名，方便debug；</li>
<li>缩小同步范围，减少锁争用；</li>
<li>多用同步工具，少用wait()和notify()；</li>
<li>使用本地变量和不可变类保证线程安全；</li>
<li>多用并发集合类；</li>
<li>使用线程池创建线程；</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/23/Spring-Cloud常见问题总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/23/Spring-Cloud常见问题总结/" class="post-title-link" itemprop="url">Spring Cloud常见问题总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-23 10:48:48" itemprop="dateCreated datePublished" datetime="2020-02-23T10:48:48+08:00">2020-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-24 09:55:37" itemprop="dateModified" datetime="2020-02-24T09:55:37+08:00">2020-02-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud/" itemprop="url" rel="index"><span itemprop="name">spring cloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>##1. 什么是微服务.</p>
<blockquote>
<p>微服务是一种架构模式，是一种特殊的分布式，提倡将单一应用程序划分成一组小的服务，每个服务运行在自己的进程中，服务之间互相协作，互相配合，<br>为用户提供服务；服务之间采用轻量级的通信机制互相沟通；</p>
</blockquote>
<p>##2. 微服务优缺点.<br>优点：</p>
<blockquote>
<p>单一职责，代码容易理解，开发效率提高，松耦合，可扩展，高可靠；</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>架构复杂，运维复杂，通信成本；</p>
</blockquote>
<p>##3. 什么是Spring Cloud.<br>Spring Cloud是基于Spring Boot的一套微服务解决方案，提供了包括服务注册和发现、配置中心、服务网关、负载均衡和路由、熔断器和链路监控等<br>组件；</p>
<p>##4. Spring Cloud和Dubbo.</p>
<blockquote>
<ul>
<li>Spring Cloud和Dubbo都是微服务架构；</li>
<li>Spring Cloud包含微服务所需的一系列组件，而Dubbo只是服务治理；</li>
<li>服务调用方式：Dubbo使用的是RPC远程调用，而Spring Cloud使用的是Rest API;</li>
<li>注册中心：Dubbo使用zookeeper作为注册中心，强调CP；Spring Cloud默认使用Eureka作为注册中心，强调AP；</li>
</ul>
</blockquote>
<p>##5. 微服务之间如何通信.</p>
<blockquote>
<ul>
<li>同步：RPC或Rest等；</li>
<li>异步：消息队列；</li>
</ul>
</blockquote>
<p>##6. Ribbon和Feign.<br>Ribbon和Feign都是客户端的负载均衡工具，Feign的底层是通过Ribbon实现的，它是对Ribbon的进一步封装；Ribbon使用HttpClient和RestTemplate<br>模拟http请求，而feign采用注解+接口方式，不需要自己构建http请求；</p>
<p>##7. Eureka的自我保护模式.<br> 默认情况下，如果EurekaServer在一定时间内没有接收到大部分微服务实例的心跳，EurekaServer将会进入自我保护模式，在该模式下EurekaServer<br> 就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出<br> 自我保护模式。</p>
<p>##8. Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别.</p>
<blockquote>
<ul>
<li>eureka保证的是AP，zookeeper保证的是CP；</li>
<li>zookeeper节点有leader和follow等角色，而eureka各个节点平等；</li>
<li>zookeeper采用过半存活原则，eureka采用自我保护机制解决分区问题；</li>
<li>eureka本质上是一个工程，而zookeeper是一个进程；</li>
</ul>
</blockquote>
<p>##9. 什么是服务熔断，什么是服务降级.<br>微服务架构中，服务之间相互调用形成调用链；当下游服务因为某些原因变得不可用或反应过慢，上游服务为了保证整体服务的可用性，不再继续调用<br>目标服务，快速返回释放资源，这种行为被称为熔断机制；熔断和降级一般配合使用，服务熔断是降级的一种方式；</p>
<p>##10. 服务雪崩.<br>微服务之间存在服务之间相互调用，当一个下游服务失败，导致整个链路的服务都失败，被称为服务雪崩；</p>
<p>##11. eureka集群怎么构建.<br>互相注册，主要配置修改如下，fetch-registry和registry-with-eureka要设置为true，并配置service-url；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka1</span><br><span class="line">  client:</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8022/eureka/</span><br></pre></td></tr></table></figure></p>
<p>##12. eureka中角色<br>eureka分为服务端和客户端，按照数据流向分为注册中心、服务提供者和服务消费者；主要由fetch-registry和registry-with-eureka参设设置；</p>
<blockquote>
<ul>
<li>服务提供者启动后，向注册中心注册；运行过程中，定时向注册中心发送心跳；停止服务时，向注册中心发送cancel请求；</li>
<li>服务消费者启动后，从注册中心拉取服务；运行过程中，定时更新注册表；</li>
<li>注册中心启动后，从其他节点拉取注册信息；运行过程中，定时清理没有按时发送心跳的服务节点；运行过程中，收到registry、renew、cancel请求，<br>都会同步到其他注册中心节点；</li>
</ul>
</blockquote>
<p>eureka数据存储结构</p>
<blockquote>
<p>分为两层：数据存储层和缓存层；eureka client在拉取服务时，会先从缓存层获取；</p>
<ul>
<li>数据存储层，是一个双层的ConcurrentHashMap结构；第一层key是spring.application.name，第二层是instanceId;</li>
<li>缓存层，分为一级缓存和二级缓存；二级缓存定时更新一级缓存；</li>
</ul>
</blockquote>
<p>服务注册机制：</p>
<blockquote>
<ol>
<li>保存服务信息，将服务信息保存到registry中；</li>
<li>更新队列，将此事件添加到更新队列中，供 Eureka Client 增量同步服务信息使用。</li>
<li>清空二级缓存，即 readWriteCacheMap，用于保证数据的一致性。</li>
<li>更新阈值，供剔除服务使用。</li>
<li>同步服务信息，将此事件同步至其他的 Eureka Server 节点。</li>
</ol>
</blockquote>
<p>服务续约机制：</p>
<blockquote>
<ol>
<li>更新服务对象的最近续约时间，即 Lease 对象的 lastUpdateTimestamp;</li>
<li>同步服务信息，将此事件同步至其他的 Eureka Server 节点。</li>
</ol>
</blockquote>
<p>服务注销机制：</p>
<blockquote>
<ol>
<li>删除服务信息，将服务信息从 registry 中删除；</li>
<li>更新队列，将此事件添加到更新队列中，供 Eureka Client 增量同步服务信息使用。</li>
<li>清空二级缓存，即 readWriteCacheMap，用于保证数据的一致性。</li>
<li>更新阈值，供剔除服务使用。</li>
<li>同步服务信息，将此事件同步至其他的 Eureka Server 节点。</li>
</ol>
</blockquote>
<p>服务剔除条件：</p>
<blockquote>
<ol>
<li>关闭了自我保护</li>
<li>如果开启了自我保护，需要进一步判断是 Eureka Server 出了问题，还是 Eureka Client 出了问题，如果是 Eureka Client 出了问题则进行剔除。<br>这里判断使用阈值；</li>
</ol>
</blockquote>
<p>##13. Ribbon负载均衡.<br>Ribbon原理：在程序启动时，如果启用了Ribbon，Ribbon会从注册中心拉取服务列表，然后根据相应的策略选择节点；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/Spring事务管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/22/Spring事务管理/" class="post-title-link" itemprop="url">Spring事务管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-22 13:47:47" itemprop="dateCreated datePublished" datetime="2020-02-22T13:47:47+08:00">2020-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-24 09:55:37" itemprop="dateModified" datetime="2020-02-24T09:55:37+08:00">2020-02-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>##1. 概述<br>事务是逻辑上的一组操作，要么都执行，要么都不执行；要满足ACID特性；</p>
<p>##2. Spring事务管理接口</p>
<blockquote>
<ul>
<li>PlatformTransactionManager：事务管理器</li>
<li>TransactionDefinition：事务定义信息（事务隔离级别、传播机制、回滚机制、超时、只读规则）</li>
<li>TransactionStatus：事务运行状态</li>
</ul>
</blockquote>
<p>Spring并不直接管理事务，而是提供多种事务管理器，将事务管理的职责委托给Hibernate和JPA等持久化<br>框架实现；</p>
<blockquote>
<p>并发事务带来的问题：</p>
<ul>
<li>脏写</li>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ul>
</blockquote>
<blockquote>
<p>事务隔离级别：</p>
<ul>
<li>读未提交TransactionDefinition.ISOLATION_READ_UNCOMMITTED</li>
<li>读已提交TransactionDefinition.ISOLATION_READ_COMMITTED</li>
<li>可重复读TransactionDefinition.ISOLATION_REPEATABLE_READ</li>
<li>序列化TransactionDefinition.ISOLATION_SERIALIZABLE</li>
<li>具体实现方式可以参考之前mysql事务部分</li>
</ul>
</blockquote>
<blockquote>
<p>事务传播机制：当一个事务方法被另一个事务方法调用时，必须指定事务如何传播</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
</blockquote>
<p>##3. Spring支持两种方式的事务管理</p>
<blockquote>
<ul>
<li>编程式事务  通过Transaction Template手动管理事务，实际应用中很少使用</li>
<li>声明式事务  推荐使用（代码侵入性最小），实际是通过AOP实现</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/动态数据源切换问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/22/动态数据源切换问题/" class="post-title-link" itemprop="url">动态数据源切换问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-22 11:19:03" itemprop="dateCreated datePublished" datetime="2020-02-22T11:19:03+08:00">2020-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-24 09:55:37" itemprop="dateModified" datetime="2020-02-24T09:55:37+08:00">2020-02-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>##1. 描述<br>有些项目需要同时操作多个数据源，这里提供一种Spring框架下最常见的解决方案。</p>
<blockquote>
<p>核心原理是利用AbstractRoutingDataSource，当项目配置AbstractRoutingDataSource数据源时，<br>每次访问数据库时会调用该类的 determineCurrentLookupKey() 方法获取数据库实例的 key，再<br>根据提前配置的key-Value数据源的映射切换到相应的数据源；</p>
</blockquote>
<blockquote>
<p>关键的几个类</p>
<ul>
<li>继承AbstractRoutingDataSource的类</li>
<li>DataSourceConfig数据源配置类</li>
<li>包含ThreadLocal变量，数据上下文配置类</li>
<li>切面类</li>
</ul>
</blockquote>
<blockquote>
<p>需要注意的几点：</p>
<ol>
<li>因为考虑到多线程并发问题，最好用ThreadLocal来实现切换获取数据库key；</li>
<li>考虑到动态切换问题，一般是利用切面，在访问dao层之前根据条件判断切换；这一步可以扩展，例如<br>利用Druid实现数据库切换和负载均衡功能，包括读写分离等；</li>
</ol>
</blockquote>
<p>##2. 实例<br>可以参考：<a href="https://github.com/haoankang/JVMProject/tree/master/Dynamic-Datasource" target="_blank" rel="noopener">https://github.com/haoankang/JVMProject/tree/master/Dynamic-Datasource</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/18/jvm详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/18/jvm详解/" class="post-title-link" itemprop="url">'jvm详解'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-18 15:20:04" itemprop="dateCreated datePublished" datetime="2020-02-18T15:20:04+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 12:30:20" itemprop="dateModified" datetime="2020-02-20T12:30:20+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1.基本问题</strong></p>
<blockquote>
<ul>
<li>java内存区域（运行时数据区）</li>
<li>java对象创建过程</li>
<li>对象的访问定位两种方式（句柄和直接指针）</li>
<li>String类和常量池</li>
</ul>
</blockquote>
<p><strong>2.运行时数据区</strong></p>
<blockquote>
<p>jdk1.8之前分为程序计数器、虚拟机栈、本地方法栈、堆、方法区（运行时常量池）、直接内存；<br>jdk1.8之后分为程序计数器、虚拟机栈、本地方法栈、堆、直接内存（元空间）；<br>以下详细说明：</p>
<ul>
<li>程序计数器：线程私有的较小内存空间，是当前线程执行字节码的信号指示器。字节码解释器工作时通过改变这个计数器的值来<br>选取下一条需要执行的字节码指令；生命周期与线程相关，不会出现异常；</li>
<li>java虚拟机栈：线程私有，描述的是java方法执行的内存模型，每次方法调用的数据都是栈传递的，由一个个栈帧组成，每个栈帧<br>都拥有：局部变量表、操作数栈、动态链接、方法出口信息； 局部变量表主要存放了编译器可知的各种基本数据类型和对象引用；<br>生命周期与线程相关，由StackOverFlowError和OutOfMemoryError两种错误；</li>
<li>本地方法栈：线程私有，和虚拟机栈作用类似，区别是：虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机使用到的Native<br>方法服务，本地方法被执行时，本地方法栈会创建一个栈帧，用于存放本地方法的局部变量表、操作数栈、动态链接、出口信息，方法执行<br>完毕后相应的栈帧出栈并释放内存空间，会抛出错误；</li>
<li>堆：线程共享，虚拟机启动时创建，此区域唯一目的是存放实例对象，几乎所有对象实例和数组都是在这里分配内存；通过-Xms和-Xmx<br>调节；</li>
<li>方法区：线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等；通过-XX:PermSize和-XX:MaxPermSize<br>调节，永久代是方法区的一种实现方式。jdk1.8之后被移除，取而代之的是元空间，使用直接内存，用-XX:MetaspaceSize和-XX:MaxMetaspaceSize<br>调节；</li>
<li>运行时常量池：是方法区的异步返，用于存储类中的常量池信息；jdk1.7之后在java堆中开辟了一块内存区域用于存放运行时常量池；</li>
<li>直接内存：直接内存不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但NIO等使用到，也会有OutOfMemoryError错误；</li>
</ul>
</blockquote>
<p><strong>3.对象创建过程</strong></p>
<blockquote>
<ol>
<li>类加载检查：虚拟机遇到new指令时，首先会检查这个指令的参数是否在常量池中定位到这个类的符号引用，并且检查符号引用代表的类是否已被<br>加载过、解析和初始化。如果没有，必须先执行相应的类加载过程；</li>
<li>分配内存：类加载检查通过后，虚拟机会为新生对象分配内存。对象所需内存大小在类加载完成后可确定；java堆中分配方式有指针碰撞和空闲列表<br>两种，选择方式由java堆是否规整决定，而java堆是否规整由垃圾收集器是否有压缩整理功能决定；</li>
<li>初始化零值；</li>
<li>设置对象头；</li>
<li>执行init方法；也就是初始化对象；</li>
</ol>
</blockquote>
<p><strong>4.对象的内存布局</strong></p>
<blockquote>
<p>Hotspot虚拟机中，对象在内存中分为三个区域：对象头、实例数据和对齐填充；<br>对象头包含两部分信息：对象自身的运行时数据（哈希码、GC分代年龄、锁状态标志）和类型指针（指向它的类元数据的指针）；<br>实例数据部分是对象真正存储的有效信息；<br>对齐填充不是必然存在的，仅仅起占位作用；</p>
</blockquote>
<p><strong>5.对象的访问定位</strong></p>
<blockquote>
<p>建立对象是为了使用，java程序通过栈上的引用数据类操作堆上具体对象，对象访问方式由虚拟机实现而定，主要有两种：使用句柄和直接指针；</p>
<ul>
<li>句柄：java堆中会划出一块内存作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>
<li>直接指针：对象实例数据中需要包含到对象类型的指针信息；</li>
<li>句柄好处是reference中存储的是稳定的句柄地址，对象移动时reference本身不改变；直接指针好处是快；</li>
</ul>
</blockquote>
<p><strong>6.类加载过程</strong></p>
<blockquote>
<p>类加载class类型文件主要三步：加载——&gt;连接（验证、准备、解析）——&gt;初始化</p>
<ul>
<li>加载：1.通过全类名获取定义此类的二进制字节流；2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构；3.在内存中生成一个代表该<br>类的CLASS对象，作为方法区这些数据的访问入口；</li>
<li>验证：文件格式验证、元数据验证、字节码验证、符号引用验证；</li>
<li>准备：正式为类变量分配内存并设置类变量初始值的阶段；</li>
<li>解析：虚拟机将常量池内的符号引用替换为直接引用的过程；</li>
<li>初始化：执行类构造器<clinit>()方法的过程；</clinit></li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/12/java基础1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/12/java基础1/" class="post-title-link" itemprop="url">java基础1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-12 15:06:04" itemprop="dateCreated datePublished" datetime="2020-02-12T15:06:04+08:00">2020-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-25 17:31:43" itemprop="dateModified" datetime="2020-02-25T17:31:43+08:00">2020-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>面向对象的特点：</p>
<blockquote>
<ul>
<li>封装：将代码及其处理的数据绑定在一起的一种编程机制；</li>
<li>继承：从已有类继承信息创建新的类；</li>
<li>抽象(N): 将一类对象的共同特征抽取出来构造类的过程；</li>
<li>多态：同一种类型的不同对象在调用相同方法时表现出不同的行为；原因是java中的变量拥有两种类型：编译时类型和运行时类型，具体表现在子类<br>重写父类方法，或者相同方法名不同参数(重载)；重载是编译时的多态性，重写是运行时的多态性；</li>
</ul>
</blockquote>
</li>
<li><p>java中变量、代码块、构造器之间的执行顺序：</p>
<blockquote>
<p>原则是先执行静态、父类、变量、代码块、构造器；因此执行顺序如下：</p>
<ol>
<li>父类中的静态变量；</li>
<li>父类中的静态代码块；</li>
<li>子类中的静态变量；</li>
<li>子类中的静态代码块；</li>
<li>父类中的普通成员变量；</li>
<li>父类中的动态代码块；</li>
<li>父类中的构造器；</li>
<li>子类中的普通成员变量；</li>
<li>子类中的动态代码块；</li>
<li>子类中的构造器；</li>
</ol>
</blockquote>
</li>
<li><p>面向对象设计原则：</p>
<blockquote>
<ul>
<li>开闭原则；</li>
<li>单一职责原则；</li>
<li>里氏代换原则；</li>
<li>依赖倒置原则；</li>
<li>接口隔离原则；</li>
<li>迪米特原则；</li>
<li>合成/聚合复用；(Extend)</li>
</ul>
</blockquote>
</li>
<li><p>String、StringBuffer、StringBuilder区别；</p>
<blockquote>
<ul>
<li>String是不可变对象，任何对string的改变都会生成新的对象；StringBuffer和StringBuilder是可变对象；</li>
<li>StringBuffer是线程安全的，StringBuilder是线程不安全的，效率上StringBuilder较高；</li>
</ul>
</blockquote>
</li>
<li><p>hashCode()和equal().</p>
<blockquote>
<p>hashCode()和equal()用于判断两个对象是否相等；hashCode()用于快速判断对象是否相等；如果hashCode()相同，equal()不一定true；<br>因为一些集合类存储元素时要判断元素是否相同，因此hashCode()和equal()都需要重写，防止集合由于误判添加重复元素；</p>
</blockquote>
</li>
<li><p>java中的内部类.</p>
<blockquote>
<p>java中的内部类分为静态内部类和非静态内部类；</p>
</blockquote>
</li>
</ol>
<p>7.反射.</p>
<blockquote>
<p>java反射是在运行时；对于任意一个已加载的类，都能知道它的所有属性和方法，对于任意的对象，都能调用它的任意方法；这种动态的获取信息和<br>动态的调用对象方法被称为java的反射；</p>
</blockquote>
<p>8.元注解.</p>
<blockquote>
<ul>
<li>@Document.是否被javadoc编入文档</li>
<li>@Target. 标识注解的范围，赋值类型是ElementType.</li>
<li>@Retention. 定义该注解的生命周期.RetentionPolicy.SOURCE、CLASS、RUNTIME.</li>
<li>@Inherited. 是否被继承.</li>
</ul>
</blockquote>
<p>9.泛型.</p>
<blockquote>
<p>泛型即参数化类型；</p>
</blockquote>
<p>10.Integer缓冲池</p>
<blockquote>
<p>new Integer(112)和Integer.valueOf(112)的区别是：new Integer(112)每次都会产生新的对象，Integer.valueOf(112)<br>会使用缓冲池中的对象，多次调用会返回同一对象；这是因为Integer内部默认有个IntegerCache缓冲池，会缓冲-128~127的对象;</p>
</blockquote>
<p>11.异常.<br>相关关键字：try..catch、finally、throw、throws；</p>
<blockquote>
<p>finally：必定执行，当try和catch中有return时，finally仍会执行，且finally比return先执行；finally是在return<br>后面的表达式运算后执行的；</p>
</blockquote>
<blockquote>
<p>finally不执行的情况：程序提前终止如调用System.exit，病毒或断电等；</p>
</blockquote>
<blockquote>
<ul>
<li>异常基类是Throwable，下面分为Error和Exception.</li>
<li>Error是指程序无法处理的错误，无法恢复也无法catch，Exception是程序可以处理的异常；</li>
<li>Exception又分为受检查异常和运行时异常；区别在于编译时是否需要处理，受检查异常编译时必须处理,例如IOException；<br>运行时异常可以处理也可以不处理；常见的运行时异常有：NullPointException、ClassCastException、IndexOutOfBoundsException、<br>IllegalArgumentException、NoSuchMethodException.</li>
</ul>
</blockquote>
<p>12.局部变量为什么一定要初始化.</p>
<blockquote>
<p>局部变量是指方法内的变量，必须初始化；因为局部变量运行时被分配在栈中，量大且生命周期短，如果虚拟机初始化开销大，但是<br>变量不初始化默认值使用是不安全的，因此出于速度和安全性考虑，局部变量需要初始化；</p>
</blockquote>
<p>13.内部类访问局部变量时，为什么变量一定要用final修饰.</p>
<blockquote>
<p>因为生命周期不同。局部变量在方法结束后销毁，内部类对象不一定，就会导致内部类引用了一个不存在的变量，所以编译器会在<br>内部类生成一个局部变量的拷贝，但如果其中一个变量修改，就会导致两个变量可能是不同的值，因此编译器要求局部变量加final，<br>保证两个变量值相同；JDK8后不需要局部变量加final，是因为编译器检查时默认加上了final.</p>
</blockquote>
<p>14.如何打破ClassLoader的双亲委托机制.</p>
<blockquote>
<p>重写loadClass().</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/22/设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ank.hao">
      <meta itemprop="description" content="技术、点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天蓝的个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/22/设计模式/" class="post-title-link" itemprop="url">'设计模式'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-22 16:11:30 / 修改时间：17:06:22" itemprop="dateCreated datePublished" datetime="2020-01-22T16:11:30+08:00">2020-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>面向对象设计原则</strong></p>
<blockquote>
<ol>
<li>开闭原则：对扩展开放、对修改关闭;</li>
<li>里氏代换原则：任何地方子类能替代其父类被调用;</li>
<li>依赖倒转原则：要依赖于抽象，而不是具体;</li>
<li>接口隔离原则：使用多个隔离接口，而不是单个接口;</li>
<li>单一职责原则：接口职责尽量单一;</li>
<li>迪米特原则： 又称最少原则，一个实体应该极可能少的与其他实体作用;</li>
<li>合成/聚合复用：尽量使用合成/聚合，而不是继承;</li>
</ol>
</blockquote>
<p><strong>创建型模式</strong></p>
<blockquote>
<ol>
<li>单例：饿汉式（提前定义，线程安全）和懒汉式（用到时创建，需要加锁保证线程安全）；</li>
<li>原型：将一个对象作为原型，通过复制object.clone()而克隆新实例；</li>
<li>工厂方法：定义一个用于创建对象的接口；</li>
<li>抽象工厂：提供一个创建产品族的接口；</li>
<li>建造者（Builder）：将一个复杂对象分解成多个部分，根据不同需要而创建它们；</li>
</ol>
</blockquote>
<p><strong>结构型模式</strong></p>
<blockquote>
<ol>
<li>代理：为对象提供一种代理访问该对象，从而限制、增强或修改对象的一些属性；</li>
<li>适配器：将一个接口转换成另外一个接口，从而使原本不兼容的类可以兼容；</li>
<li>装饰：动态的给对象添加一些额外功能;</li>
<li>桥接：将抽象与实现分离，使它们独立变化。通过组合来代替继承；</li>
<li>门面：又称外观模式；对多个复杂的子系统提供一个一致的接口；</li>
<li>享元：运用共享技术有效的支持大量细粒度对象的调用；</li>
<li>组合：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性；</li>
</ol>
</blockquote>
<p><strong>行为模式</strong></p>
<blockquote>
<ol>
<li>模板方法：定义一个操作中的算法骨架，将实现延迟到子类中，使得子类在不改变算法结构的情况下重新定义算法中的某些步骤；</li>
<li>策略：定义一些了算法，并将每个算法封装起来，使他们可以相互替换；</li>
<li>命令：将一个请求封装成一个对象，使发出请求的责任和执行请求的责任分开；</li>
<li>职责链：把请求从链中的一个对象传到下一个对象，直到请求相应为止，通过这种方式去除对象间的耦合；</li>
<li>状态：允许一个对象在其内部状态发生改变时改变其行为能力；</li>
<li>观察者：多个对象间存在一对多关系，当一个对象改变时，把这种改变通知给其他多个对象；</li>
<li>中介者：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必互相了解；</li>
<li>迭代器：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示；</li>
<li>访问者：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素由多个访问者对象访问；<br>10.备忘录：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便之后恢复；<br>11.解释器：提供如何定义语言的文法，以及对语言句子的解释方法；</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ank.hao</p>
  <div class="site-description" itemprop="description">技术、点滴</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ank.hao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
